/*
Copyright [2019] [Kieran White]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

///
/// Macro that creates an enum wrapper with a variant corresponding to
/// each of a series of either encapsulated or new errors.
///
/// The macro also implements the From trait for the enum allowing the
/// user to convert one of the encapsulated errors (or indeed any
/// arbitrary payload where the user is creating a new error) into one of
/// the enum variants.
///
/// # Examples
///
/// ```
/// use std::fs::File;
/// use io::Error;
/// 
/// #[derive(Clone, Debug)]
/// pub struct Pin(pub usize);
///
/// err!(Error {
///	 #[doc="Errors can that can be generated when reading GPIOs"]
///	 File(io::Error),
///	 InvalidPin(Pin)
/// });
///
/// type GPIOResult<T>=Result<T, Error>
/// ```
/// 
/// Instantiate a Pin error as follow:
///
///```
/// let pin_error=Error::InvalidPin(Pin(3));
/// ```
/// 
/// Or we can wrap errors generated by a function that returns
/// std::io::Result using Rust's usual error propagation operator. For
/// example from within a function that returns a GPIOResult (defined
/// above) we can do the following:
/// 
/// ```
/// let f = File::open("/dev/gpiomem")?;
/// ```
#[macro_export]
macro_rules! err {
    ($(#[$outer:meta])* $enum_name:ident { $( $var:ident($embedded:path) ),+ } ) => {
        $(#[$outer])*
        #[derive(Debug)]
        pub enum $enum_name {
            $(
                $var($embedded),
            )*
        }

        $(
            impl From<$embedded> for $enum_name {
                fn from(orig: $embedded) -> $enum_name {
                    use log::error;

                    error!("err: {:?} into {:?}::{:?}({:?})", stringify!($embedded), stringify!($enum_name), stringify!($var), stringify!($embedded));
                    $enum_name::$var(orig)
                }
            }
        )*

    };
}
