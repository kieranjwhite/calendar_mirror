// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

use dbus as dbus;
use dbus::arg;

pub trait OrgFreedesktopDBusPeer {
    type Err;
    fn ping(&self) -> Result<(), Self::Err>;
    fn get_machine_id(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgFreedesktopDBusPeer for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn ping(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Peer".into(), &"Ping".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn get_machine_id(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Peer".into(), &"GetMachineId".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let machine_uuid: String = i.read()?;
        Ok(machine_uuid)
    }
}

pub trait OrgFreedesktopDBusIntrospectable {
    type Err;
    fn introspect(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgFreedesktopDBusIntrospectable for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn introspect(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Introspectable".into(), &"Introspect".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let data: String = i.read()?;
        Ok(data)
    }
}

pub trait OrgFreedesktopDBusProperties {
    type Err;
    fn get<R0: for<'b> arg::Get<'b>>(&self, interface: &str, property: &str) -> Result<arg::Variant<R0>, Self::Err>;
    fn get_all(&self, interface: &str) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>>, Self::Err>;
    fn set<I2: arg::Arg + arg::Append>(&self, interface: &str, property: &str, value: arg::Variant<I2>) -> Result<(), Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgFreedesktopDBusProperties for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn get<R0: for<'b> arg::Get<'b>>(&self, interface: &str, property: &str) -> Result<arg::Variant<R0>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"Get".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(interface);
            i.append(property);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let value: arg::Variant<R0> = i.read()?;
        Ok(value)
    }

    fn get_all(&self, interface: &str) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"GetAll".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(interface);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let properties: ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>> = i.read()?;
        Ok(properties)
    }

    fn set<I2: arg::Arg + arg::Append>(&self, interface: &str, property: &str, value: arg::Variant<I2>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"Set".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(interface);
            i.append(property);
            i.append(value);
        })?;
        m.as_result()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface: String,
    pub changed_properties: ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>>,
    pub invalidated_properties: Vec<String>,
}

impl dbus::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.interface = i.read()?;
        self.changed_properties = i.read()?;
        self.invalidated_properties = i.read()?;
        Ok(())
    }
}

pub trait OrgFreedesktopSystemd1Manager {
    type Err;
    fn get_unit(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_unit_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_unit_by_invocation_id(&self, arg0: Vec<u8>) -> Result<dbus::Path<'static>, Self::Err>;
    fn load_unit(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn start_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn start_unit_replace(&self, arg0: &str, arg1: &str, arg2: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn stop_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn reload_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn try_restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn reload_or_restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn reload_or_try_restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn kill_unit(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), Self::Err>;
    fn reset_failed_unit(&self, arg0: &str) -> Result<(), Self::Err>;
    fn set_unit_properties(&self, arg0: &str, arg1: bool, arg2: Vec<(&str, arg::Variant<Box<arg::RefArg>>)>) -> Result<(), Self::Err>;
    fn ref_unit(&self, arg0: &str) -> Result<(), Self::Err>;
    fn unref_unit(&self, arg0: &str) -> Result<(), Self::Err>;
    fn start_transient_unit(&self, arg0: &str, arg1: &str, arg2: Vec<(&str, arg::Variant<Box<arg::RefArg>>)>, arg3: Vec<(&str, Vec<(&str, arg::Variant<Box<arg::RefArg>>)>)>) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_unit_processes(&self, arg0: &str) -> Result<Vec<(String, u32, String)>, Self::Err>;
    fn get_job(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_job_after(&self, arg0: u32) -> Result<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, Self::Err>;
    fn get_job_before(&self, arg0: u32) -> Result<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, Self::Err>;
    fn cancel_job(&self, arg0: u32) -> Result<(), Self::Err>;
    fn clear_jobs(&self) -> Result<(), Self::Err>;
    fn reset_failed(&self) -> Result<(), Self::Err>;
    fn list_units(&self) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, Self::Err>;
    fn list_units_filtered(&self, arg0: Vec<&str>) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, Self::Err>;
    fn list_units_by_patterns(&self, arg0: Vec<&str>, arg1: Vec<&str>) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, Self::Err>;
    fn list_units_by_names(&self, arg0: Vec<&str>) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, Self::Err>;
    fn list_jobs(&self) -> Result<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, Self::Err>;
    fn subscribe(&self) -> Result<(), Self::Err>;
    fn unsubscribe(&self) -> Result<(), Self::Err>;
    fn dump(&self) -> Result<String, Self::Err>;
    fn create_snapshot(&self, arg0: &str, arg1: bool) -> Result<dbus::Path<'static>, Self::Err>;
    fn remove_snapshot(&self, arg0: &str) -> Result<(), Self::Err>;
    fn reload(&self) -> Result<(), Self::Err>;
    fn reexecute(&self) -> Result<(), Self::Err>;
    fn exit(&self) -> Result<(), Self::Err>;
    fn reboot(&self) -> Result<(), Self::Err>;
    fn power_off(&self) -> Result<(), Self::Err>;
    fn halt(&self) -> Result<(), Self::Err>;
    fn kexec(&self) -> Result<(), Self::Err>;
    fn switch_root(&self, arg0: &str, arg1: &str) -> Result<(), Self::Err>;
    fn set_environment(&self, arg0: Vec<&str>) -> Result<(), Self::Err>;
    fn unset_environment(&self, arg0: Vec<&str>) -> Result<(), Self::Err>;
    fn unset_and_set_environment(&self, arg0: Vec<&str>, arg1: Vec<&str>) -> Result<(), Self::Err>;
    fn list_unit_files(&self) -> Result<Vec<(String, String)>, Self::Err>;
    fn list_unit_files_by_patterns(&self, arg0: Vec<&str>, arg1: Vec<&str>) -> Result<Vec<(String, String)>, Self::Err>;
    fn get_unit_file_state(&self, arg0: &str) -> Result<String, Self::Err>;
    fn enable_unit_files(&self, arg0: Vec<&str>, arg1: bool, arg2: bool) -> Result<(bool, Vec<(String, String, String)>), Self::Err>;
    fn disable_unit_files(&self, arg0: Vec<&str>, arg1: bool) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn reenable_unit_files(&self, arg0: Vec<&str>, arg1: bool, arg2: bool) -> Result<(bool, Vec<(String, String, String)>), Self::Err>;
    fn link_unit_files(&self, arg0: Vec<&str>, arg1: bool, arg2: bool) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn preset_unit_files(&self, arg0: Vec<&str>, arg1: bool, arg2: bool) -> Result<(bool, Vec<(String, String, String)>), Self::Err>;
    fn preset_unit_files_with_mode(&self, arg0: Vec<&str>, arg1: &str, arg2: bool, arg3: bool) -> Result<(bool, Vec<(String, String, String)>), Self::Err>;
    fn mask_unit_files(&self, arg0: Vec<&str>, arg1: bool, arg2: bool) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn unmask_unit_files(&self, arg0: Vec<&str>, arg1: bool) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn revert_unit_files(&self, arg0: Vec<&str>) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn set_default_target(&self, arg0: &str, arg1: bool) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn get_default_target(&self) -> Result<String, Self::Err>;
    fn preset_all_unit_files(&self, arg0: &str, arg1: bool, arg2: bool) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn add_dependency_unit_files(&self, arg0: Vec<&str>, arg1: &str, arg2: &str, arg3: bool, arg4: bool) -> Result<Vec<(String, String, String)>, Self::Err>;
    fn get_unit_file_links(&self, arg0: &str, arg1: bool) -> Result<Vec<String>, Self::Err>;
    fn set_exit_code(&self, arg0: u8) -> Result<(), Self::Err>;
    fn lookup_dynamic_user_by_name(&self, arg0: &str) -> Result<u32, Self::Err>;
    fn lookup_dynamic_user_by_uid(&self, arg0: u32) -> Result<String, Self::Err>;
    fn get_version(&self) -> Result<String, Self::Err>;
    fn get_features(&self) -> Result<String, Self::Err>;
    fn get_virtualization(&self) -> Result<String, Self::Err>;
    fn get_architecture(&self) -> Result<String, Self::Err>;
    fn get_tainted(&self) -> Result<String, Self::Err>;
    fn get_firmware_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_firmware_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_loader_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_loader_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_kernel_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_kernel_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_init_rdtimestamp(&self) -> Result<u64, Self::Err>;
    fn get_init_rdtimestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_userspace_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_userspace_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_security_start_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_security_start_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_security_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_security_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_generators_start_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_generators_start_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_generators_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_generators_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_units_load_start_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_units_load_start_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_units_load_finish_timestamp(&self) -> Result<u64, Self::Err>;
    fn get_units_load_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_log_level(&self) -> Result<String, Self::Err>;
    fn set_log_level(&self, value: String) -> Result<(), Self::Err>;
    fn get_log_target(&self) -> Result<String, Self::Err>;
    fn set_log_target(&self, value: String) -> Result<(), Self::Err>;
    fn get_nnames(&self) -> Result<u32, Self::Err>;
    fn get_nfailed_units(&self) -> Result<u32, Self::Err>;
    fn get_njobs(&self) -> Result<u32, Self::Err>;
    fn get_ninstalled_jobs(&self) -> Result<u32, Self::Err>;
    fn get_nfailed_jobs(&self) -> Result<u32, Self::Err>;
    fn get_progress(&self) -> Result<f64, Self::Err>;
    fn get_environment(&self) -> Result<Vec<String>, Self::Err>;
    fn get_confirm_spawn(&self) -> Result<bool, Self::Err>;
    fn get_show_status(&self) -> Result<bool, Self::Err>;
    fn get_unit_path(&self) -> Result<Vec<String>, Self::Err>;
    fn get_default_standard_output(&self) -> Result<String, Self::Err>;
    fn get_default_standard_error(&self) -> Result<String, Self::Err>;
    fn get_runtime_watchdog_usec(&self) -> Result<u64, Self::Err>;
    fn set_runtime_watchdog_usec(&self, value: u64) -> Result<(), Self::Err>;
    fn get_shutdown_watchdog_usec(&self) -> Result<u64, Self::Err>;
    fn set_shutdown_watchdog_usec(&self, value: u64) -> Result<(), Self::Err>;
    fn get_service_watchdogs(&self) -> Result<bool, Self::Err>;
    fn set_service_watchdogs(&self, value: bool) -> Result<(), Self::Err>;
    fn get_control_group(&self) -> Result<String, Self::Err>;
    fn get_system_state(&self) -> Result<String, Self::Err>;
    fn get_exit_code(&self) -> Result<u8, Self::Err>;
    fn get_default_timer_accuracy_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_timeout_start_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_timeout_stop_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_restart_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_start_limit_interval_usec(&self) -> Result<u64, Self::Err>;
    fn get_default_start_limit_burst(&self) -> Result<u32, Self::Err>;
    fn get_default_cpuaccounting(&self) -> Result<bool, Self::Err>;
    fn get_default_block_ioaccounting(&self) -> Result<bool, Self::Err>;
    fn get_default_memory_accounting(&self) -> Result<bool, Self::Err>;
    fn get_default_tasks_accounting(&self) -> Result<bool, Self::Err>;
    fn get_default_limit_cpu(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_cpusoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_fsize(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_fsizesoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_data(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_datasoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_stack(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_stacksoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_core(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_coresoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rss(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rsssoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nofile(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nofilesoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_as(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_assoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nproc(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nprocsoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_memlock(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_memlocksoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_locks(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_lockssoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_sigpending(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_sigpendingsoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_msgqueue(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_msgqueuesoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nice(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_nicesoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rtprio(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rtpriosoft(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rttime(&self) -> Result<u64, Self::Err>;
    fn get_default_limit_rttimesoft(&self) -> Result<u64, Self::Err>;
    fn get_default_tasks_max(&self) -> Result<u64, Self::Err>;
    fn get_timer_slack_nsec(&self) -> Result<u64, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgFreedesktopSystemd1Manager for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn get_unit(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"GetUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"GetUnitByPID".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_by_invocation_id(&self, arg0: Vec<u8>) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"GetUnitByInvocationID".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn load_unit(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"LoadUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn start_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"StartUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn start_unit_replace(&self, arg0: &str, arg1: &str, arg2: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"StartUnitReplace".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn stop_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"StopUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn reload_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ReloadUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"RestartUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn try_restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"TryRestartUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn reload_or_restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ReloadOrRestartUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn reload_or_try_restart_unit(&self, arg0: &str, arg1: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ReloadOrTryRestartUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn kill_unit(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"KillUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn reset_failed_unit(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ResetFailedUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn set_unit_properties(&self, arg0: &str, arg1: bool, arg2: Vec<(&str, arg::Variant<Box<arg::RefArg>>)>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"SetUnitProperties".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn ref_unit(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"RefUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unref_unit(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"UnrefUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn start_transient_unit(&self, arg0: &str, arg1: &str, arg2: Vec<(&str, arg::Variant<Box<arg::RefArg>>)>, arg3: Vec<(&str, Vec<(&str, arg::Variant<Box<arg::RefArg>>)>)>) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"StartTransientUnit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
            i.append(arg3);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_processes(&self, arg0: &str) -> Result<Vec<(String, u32, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"GetUnitProcesses".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, u32, String)> = i.read()?;
        Ok(arg0)
    }

    fn get_job(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"GetJob".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_job_after(&self, arg0: u32) -> Result<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"GetJobAfter".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn get_job_before(&self, arg0: u32) -> Result<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"GetJobBefore".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn cancel_job(&self, arg0: u32) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"CancelJob".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn clear_jobs(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ClearJobs".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn reset_failed(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ResetFailed".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn list_units(&self) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ListUnits".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn list_units_filtered(&self, arg0: Vec<&str>) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ListUnitsFiltered".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn list_units_by_patterns(&self, arg0: Vec<&str>, arg1: Vec<&str>) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ListUnitsByPatterns".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn list_units_by_names(&self, arg0: Vec<&str>) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ListUnitsByNames".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn list_jobs(&self) -> Result<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ListJobs".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn subscribe(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"Subscribe".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unsubscribe(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"Unsubscribe".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn dump(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"Dump".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn create_snapshot(&self, arg0: &str, arg1: bool) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"CreateSnapshot".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn remove_snapshot(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"RemoveSnapshot".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn reload(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"Reload".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn reexecute(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"Reexecute".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn exit(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"Exit".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn reboot(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"Reboot".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn power_off(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"PowerOff".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn halt(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"Halt".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn kexec(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"KExec".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn switch_root(&self, arg0: &str, arg1: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"SwitchRoot".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn set_environment(&self, arg0: Vec<&str>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"SetEnvironment".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unset_environment(&self, arg0: Vec<&str>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"UnsetEnvironment".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unset_and_set_environment(&self, arg0: Vec<&str>, arg1: Vec<&str>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"UnsetAndSetEnvironment".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn list_unit_files(&self) -> Result<Vec<(String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ListUnitFiles".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String)> = i.read()?;
        Ok(arg0)
    }

    fn list_unit_files_by_patterns(&self, arg0: Vec<&str>, arg1: Vec<&str>) -> Result<Vec<(String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ListUnitFilesByPatterns".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String)> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_file_state(&self, arg0: &str) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"GetUnitFileState".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn enable_unit_files(&self, arg0: Vec<&str>, arg1: bool, arg2: bool) -> Result<(bool, Vec<(String, String, String)>), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"EnableUnitFiles".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: bool = i.read()?;
        let arg1: Vec<(String, String, String)> = i.read()?;
        Ok((arg0, arg1))
    }

    fn disable_unit_files(&self, arg0: Vec<&str>, arg1: bool) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"DisableUnitFiles".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn reenable_unit_files(&self, arg0: Vec<&str>, arg1: bool, arg2: bool) -> Result<(bool, Vec<(String, String, String)>), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"ReenableUnitFiles".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: bool = i.read()?;
        let arg1: Vec<(String, String, String)> = i.read()?;
        Ok((arg0, arg1))
    }

    fn link_unit_files(&self, arg0: Vec<&str>, arg1: bool, arg2: bool) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"LinkUnitFiles".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn preset_unit_files(&self, arg0: Vec<&str>, arg1: bool, arg2: bool) -> Result<(bool, Vec<(String, String, String)>), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"PresetUnitFiles".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: bool = i.read()?;
        let arg1: Vec<(String, String, String)> = i.read()?;
        Ok((arg0, arg1))
    }

    fn preset_unit_files_with_mode(&self, arg0: Vec<&str>, arg1: &str, arg2: bool, arg3: bool) -> Result<(bool, Vec<(String, String, String)>), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"PresetUnitFilesWithMode".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
            i.append(arg3);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: bool = i.read()?;
        let arg1: Vec<(String, String, String)> = i.read()?;
        Ok((arg0, arg1))
    }

    fn mask_unit_files(&self, arg0: Vec<&str>, arg1: bool, arg2: bool) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"MaskUnitFiles".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn unmask_unit_files(&self, arg0: Vec<&str>, arg1: bool) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"UnmaskUnitFiles".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn revert_unit_files(&self, arg0: Vec<&str>) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"RevertUnitFiles".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn set_default_target(&self, arg0: &str, arg1: bool) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"SetDefaultTarget".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn get_default_target(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"GetDefaultTarget".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn preset_all_unit_files(&self, arg0: &str, arg1: bool, arg2: bool) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"PresetAllUnitFiles".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn add_dependency_unit_files(&self, arg0: Vec<&str>, arg1: &str, arg2: &str, arg3: bool, arg4: bool) -> Result<Vec<(String, String, String)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"AddDependencyUnitFiles".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
            i.append(arg3);
            i.append(arg4);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String)> = i.read()?;
        Ok(arg0)
    }

    fn get_unit_file_links(&self, arg0: &str, arg1: bool) -> Result<Vec<String>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"GetUnitFileLinks".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<String> = i.read()?;
        Ok(arg0)
    }

    fn set_exit_code(&self, arg0: u8) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"SetExitCode".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn lookup_dynamic_user_by_name(&self, arg0: &str) -> Result<u32, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"LookupDynamicUserByName".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: u32 = i.read()?;
        Ok(arg0)
    }

    fn lookup_dynamic_user_by_uid(&self, arg0: u32) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.systemd1.Manager".into(), &"LookupDynamicUserByUID".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn get_version(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Version")
    }

    fn get_features(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Features")
    }

    fn get_virtualization(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Virtualization")
    }

    fn get_architecture(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Architecture")
    }

    fn get_tainted(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Tainted")
    }

    fn get_firmware_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "FirmwareTimestamp")
    }

    fn get_firmware_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "FirmwareTimestampMonotonic")
    }

    fn get_loader_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "LoaderTimestamp")
    }

    fn get_loader_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "LoaderTimestampMonotonic")
    }

    fn get_kernel_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "KernelTimestamp")
    }

    fn get_kernel_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "KernelTimestampMonotonic")
    }

    fn get_init_rdtimestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDTimestamp")
    }

    fn get_init_rdtimestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDTimestampMonotonic")
    }

    fn get_userspace_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UserspaceTimestamp")
    }

    fn get_userspace_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UserspaceTimestampMonotonic")
    }

    fn get_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "FinishTimestamp")
    }

    fn get_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "FinishTimestampMonotonic")
    }

    fn get_security_start_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "SecurityStartTimestamp")
    }

    fn get_security_start_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "SecurityStartTimestampMonotonic")
    }

    fn get_security_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "SecurityFinishTimestamp")
    }

    fn get_security_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "SecurityFinishTimestampMonotonic")
    }

    fn get_generators_start_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "GeneratorsStartTimestamp")
    }

    fn get_generators_start_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "GeneratorsStartTimestampMonotonic")
    }

    fn get_generators_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "GeneratorsFinishTimestamp")
    }

    fn get_generators_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "GeneratorsFinishTimestampMonotonic")
    }

    fn get_units_load_start_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitsLoadStartTimestamp")
    }

    fn get_units_load_start_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitsLoadStartTimestampMonotonic")
    }

    fn get_units_load_finish_timestamp(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitsLoadFinishTimestamp")
    }

    fn get_units_load_finish_timestamp_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitsLoadFinishTimestampMonotonic")
    }

    fn get_log_level(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "LogLevel")
    }

    fn get_log_target(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "LogTarget")
    }

    fn get_nnames(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "NNames")
    }

    fn get_nfailed_units(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "NFailedUnits")
    }

    fn get_njobs(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "NJobs")
    }

    fn get_ninstalled_jobs(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "NInstalledJobs")
    }

    fn get_nfailed_jobs(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "NFailedJobs")
    }

    fn get_progress(&self) -> Result<f64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Progress")
    }

    fn get_environment(&self) -> Result<Vec<String>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Environment")
    }

    fn get_confirm_spawn(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ConfirmSpawn")
    }

    fn get_show_status(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ShowStatus")
    }

    fn get_unit_path(&self) -> Result<Vec<String>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitPath")
    }

    fn get_default_standard_output(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultStandardOutput")
    }

    fn get_default_standard_error(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultStandardError")
    }

    fn get_runtime_watchdog_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "RuntimeWatchdogUSec")
    }

    fn get_shutdown_watchdog_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ShutdownWatchdogUSec")
    }

    fn get_service_watchdogs(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ServiceWatchdogs")
    }

    fn get_control_group(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ControlGroup")
    }

    fn get_system_state(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "SystemState")
    }

    fn get_exit_code(&self) -> Result<u8, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ExitCode")
    }

    fn get_default_timer_accuracy_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTimerAccuracyUSec")
    }

    fn get_default_timeout_start_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTimeoutStartUSec")
    }

    fn get_default_timeout_stop_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTimeoutStopUSec")
    }

    fn get_default_restart_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultRestartUSec")
    }

    fn get_default_start_limit_interval_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultStartLimitIntervalUSec")
    }

    fn get_default_start_limit_burst(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultStartLimitBurst")
    }

    fn get_default_cpuaccounting(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultCPUAccounting")
    }

    fn get_default_block_ioaccounting(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultBlockIOAccounting")
    }

    fn get_default_memory_accounting(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultMemoryAccounting")
    }

    fn get_default_tasks_accounting(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTasksAccounting")
    }

    fn get_default_limit_cpu(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitCPU")
    }

    fn get_default_limit_cpusoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitCPUSoft")
    }

    fn get_default_limit_fsize(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitFSIZE")
    }

    fn get_default_limit_fsizesoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitFSIZESoft")
    }

    fn get_default_limit_data(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitDATA")
    }

    fn get_default_limit_datasoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitDATASoft")
    }

    fn get_default_limit_stack(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitSTACK")
    }

    fn get_default_limit_stacksoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitSTACKSoft")
    }

    fn get_default_limit_core(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitCORE")
    }

    fn get_default_limit_coresoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitCORESoft")
    }

    fn get_default_limit_rss(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRSS")
    }

    fn get_default_limit_rsssoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRSSSoft")
    }

    fn get_default_limit_nofile(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNOFILE")
    }

    fn get_default_limit_nofilesoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNOFILESoft")
    }

    fn get_default_limit_as(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitAS")
    }

    fn get_default_limit_assoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitASSoft")
    }

    fn get_default_limit_nproc(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNPROC")
    }

    fn get_default_limit_nprocsoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNPROCSoft")
    }

    fn get_default_limit_memlock(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitMEMLOCK")
    }

    fn get_default_limit_memlocksoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitMEMLOCKSoft")
    }

    fn get_default_limit_locks(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitLOCKS")
    }

    fn get_default_limit_lockssoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitLOCKSSoft")
    }

    fn get_default_limit_sigpending(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitSIGPENDING")
    }

    fn get_default_limit_sigpendingsoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitSIGPENDINGSoft")
    }

    fn get_default_limit_msgqueue(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitMSGQUEUE")
    }

    fn get_default_limit_msgqueuesoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitMSGQUEUESoft")
    }

    fn get_default_limit_nice(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNICE")
    }

    fn get_default_limit_nicesoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNICESoft")
    }

    fn get_default_limit_rtprio(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRTPRIO")
    }

    fn get_default_limit_rtpriosoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRTPRIOSoft")
    }

    fn get_default_limit_rttime(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRTTIME")
    }

    fn get_default_limit_rttimesoft(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRTTIMESoft")
    }

    fn get_default_tasks_max(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTasksMax")
    }

    fn get_timer_slack_nsec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "TimerSlackNSec")
    }

    fn set_log_level(&self, value: String) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "LogLevel", value)
    }

    fn set_log_target(&self, value: String) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "LogTarget", value)
    }

    fn set_runtime_watchdog_usec(&self, value: u64) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "RuntimeWatchdogUSec", value)
    }

    fn set_shutdown_watchdog_usec(&self, value: u64) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "ShutdownWatchdogUSec", value)
    }

    fn set_service_watchdogs(&self, value: bool) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "ServiceWatchdogs", value)
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerUnitNew {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerUnitNew {
    const NAME: &'static str = "UnitNew";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerUnitRemoved {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerUnitRemoved {
    const NAME: &'static str = "UnitRemoved";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerJobNew {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
    pub arg2: String,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerJobNew {
    const NAME: &'static str = "JobNew";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
        arg::RefArg::append(&self.arg2, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        self.arg2 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerJobRemoved {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
    pub arg2: String,
    pub arg3: String,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerJobRemoved {
    const NAME: &'static str = "JobRemoved";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
        arg::RefArg::append(&self.arg2, i);
        arg::RefArg::append(&self.arg3, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        self.arg2 = i.read()?;
        self.arg3 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerStartupFinished {
    pub arg0: u64,
    pub arg1: u64,
    pub arg2: u64,
    pub arg3: u64,
    pub arg4: u64,
    pub arg5: u64,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerStartupFinished {
    const NAME: &'static str = "StartupFinished";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
        arg::RefArg::append(&self.arg2, i);
        arg::RefArg::append(&self.arg3, i);
        arg::RefArg::append(&self.arg4, i);
        arg::RefArg::append(&self.arg5, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        self.arg2 = i.read()?;
        self.arg3 = i.read()?;
        self.arg4 = i.read()?;
        self.arg5 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerUnitFilesChanged {
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    const NAME: &'static str = "UnitFilesChanged";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, _: &mut arg::IterAppend) {
    }
    fn get(&mut self, _: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopSystemd1ManagerReloading {
    pub arg0: bool,
}

impl dbus::SignalArgs for OrgFreedesktopSystemd1ManagerReloading {
    const NAME: &'static str = "Reloading";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        Ok(())
    }
}
